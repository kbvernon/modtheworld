[["index.html", "Modeling the World with R Welcome", " Modeling the World with R Kenneth Blake Vernon 2021-01-17 Welcome This is the website for “Modeling the World with R”, a bookdown project for a university course that introduces students to the fundamentals of statistics and statistical programming in R. While geared toward practical applications, like analyzing and visualizing data, this book aims to promote higher-order understanding of statistical concepts and theory too - not just the how, but the why. The reader will, thus, come away with a better sense of statistical relevance; meaning, they will be able to start with a scientific question, translate it into a more precise statistical form, identify the appropriate statistical methods, and then use the statistical programming tools offered by R to implement those methods efficiently. In a word, then, the book aims to make the reader a more efficient and more thoughtful empirical modeler. By contributing to Modeling the World, you agree to follow its Contributor Code of Conduct. "],["acknowledgments.html", "Acknowledgments", " Acknowledgments "],["intro.html", "Chapter 1 Introduction 1.1 Who is this bookdown for? 1.2 Why this bookdown project? 1.3 Pedagogy 1.4 The Abelson Principle 1.5 Book layout 1.6 R code formatting 1.7 Exercises and data", " Chapter 1 Introduction This book provides an advanced introduction to doing statistics with R (R Core Team 2020b), equipping the reader with the programming skills necessary to do statistics cheaply, efficiently - and perhaps most importantly - in a reproducible fashion. 1.1 Who is this bookdown for? It is primarily geared toward students who have some familiarity with basic statistical concepts. In the United States, that would be advanced undergraduates and beginning graduate students. While it does cover much of the same ground as an introductory course, it covers those topics in greater detail and with an eye toward exploring those statistical concepts within R. The hope is that being a better R programmer will make you a better statistician and that being a better statistician will make you a better R programmer. 1.2 Why this bookdown project? Lots of really good resources for learning R and/or statistics exist, for example, Cetinkaya-Rundel and Hardin (2020) “Introduction to Modern Statistics” Ismay and Kim (2020) “Statistical Inference via Data Science” Phillips (2018) “YaRrr! The Pirate’s Guide to R” Wickham and Grolemund (2017) “R for Data Science” So, why write another one? The best way to answer that question is probably with the big idea motivating this material, specifically the intuition that statistics is, in the first place, a framework for building and evaluating models of the world. This idea guides the book’s layout and content, providing a fresh approach to statistics and statistical programming. It may be juxtaposed with a common strategy for teaching introductory statistics, which goes something like this. First, you introduce students to some descriptive statistics, beginning with properties of a single variable, including measures of its central tendency, its variability, and its shape and skew. From there, you move on to discussing various significance tests, like Student’s T. Finally, you reach the topic of modeling, covering such things as ordinary least squares and perhaps generalized linear modeling. If you had to give it a name, you might call this breezy strategy the Describe-Test-Model (DTM) paradigm of statistics pedagogy. As an alternative to DTM, this book adopts an Everything-is-a-Model (EM) approach. EM has many advantages over DTM, but perhaps the two most important are these: It is more intuitive. It starts from the idea that when we use statistics, our primary goal is to understand an empirical (or data generating) process, be it the efficacy of a medical treatment, the causes of ocean fishery collapse, or simply differences in the height of actors who auditioned for the roles of Aragorn and Gimli in the timeless cinematic classic, The Lord of the Rings. We do that by first proposing a model of the target process (this is statistical description) and then to ask if our proposed model is better at describing that process than alternatives (this is statistical inference). It emphasizes critical thinking. A fundamental weakness of the DTM approach is its emphasis on rote learning. Students are trained to be, as it were, statistical parrots, able to reliably squawk “aark! t-test!” in the correct circumstances without ever understanding that test’s meaning. By emphasizing statistical inference as a method for choosing between models, the EM approach invites the student to move beyond this simple statistical parroting, to actively think about what it is they are doing when they apply a statistical test. And, for the statistical purists out there, EM ruthlessly enforces the distinction between statistical description and statistical inference. For details about this perspective, have a look at Chapter 12 What is statistics?. To see how someone might take the EM approach and run off a cliff with it, have a look at Jonas Kristoffer Lindelov’s very insightful and very enjoyable article Common statistical tests are linear models (or: how to teach stats). Now, if I’m being honest, there are a few additional reasons to prefer this book over others. First, it’s brief. That’s because it doesn’t try to do everything. At the end of the day, there’s no substituting for the guiding hand of a thoughtful teacher. This book embraces that idea, offloading a lot of what is “unsaid” into the classroom. For instance, there’s no discussion of how to install R! Second, the book does not shy away from mathematical notation, which seems to be more in vogue these days, though it does so sparingly. Third, it doesn’t treat you like a child. As far as we are concerned, you’re an adult, so we treat you like you one. Of course, that’s not to say this book doesn’t have a sense of humor. It very much does, which brings me to the final reason you should prefer this book. The humor in it is mine. 1.3 Pedagogy To understand the pedagogy adopted here, consider by analogy the plight of an exchange student venturing abroad to learn a new language. What we might call the pure inquiry-based approach to the student’s situation would be to, well, parachute them into the heart of a foreign land, perhaps offering them a swift kick and a lackadaisical “good luck!” on their way out. Alternatively, we could adopt a pure instructor-driven approach. You know the kind, drills, repetition, and rote memorization, Monday Tuesday Wednesday Thursday Friday, always the same, until you’ve snuffed out the last spark of curiosity. With the former approach, the student will almost assuredly become hopelessly lost. With the latter, of course, they will simply check out. To avoid these unwanted outcomes, we adopt a hybrid approach to teaching statistics and statistical programming in R, starting with traditional instructor-driven factual knowledge to present basic R concepts and then moving to a more inquiry-based or question-oriented approach1 to explore statistical concepts. So, we provide the reader with some basic R scaffolding, which they can then extend and enrich through their question-directed, deep-dive into fundamental statistics. Of course, that’s not to say that the R introduction is entirely declarative, or the statistics introduction entirely interrogative. For we encourage the reader to think about R programming tools in terms of how they complement the scientific method. And, we also provide explanations of statistical concepts, too. I mean, we’re not going to ask the reader to interrogate their way from Pythagoras to R.A. Fisher. The idea is, instead, to always draw their attention to and ask them to think deeply about how one uses quantitative methods to choose between alternative statistical models of the underlying process we hope to understand. 1.4 The Abelson Principle A lot of instruction in programming seems to focus on how one must write it, without ever explaining how one should write it. This is a mistake, akin to teaching someone to speak a language but not how to communicate with it effectively. We want to avoid this, so we provide a style guide right away (Chapter 5). Obviously, such a guide cannot avoid being arbitrary (in the sense of lacking an objective “foundation”), but that doesn’t mean it can’t still be reasonable. To ensure its reasonableness, we emphasize with our guide the writing of code that promotes reproducible research, where ‘reproducibility’ refers to the ability of different individuals to obtain the same or similar results when implementing the same or similar methods. With respect to reproducible programming, perhaps the most important thing you can do is ensure that your code satisfies what we refer to as the Abelson Principle2: Programs must be written for people to read, and only incidentally for machines to execute. -Hal Abelson, The Structure and Interpretation of Computer Programs To unpack that a little, we might say that R code should be (i) clear, (ii) concise, and (iii) organized. Clear code wears its meaning on its sleeve. While code can and often does get very complicated, one should always take care to ensure that discerning its intent is as easy as possible. Concise code sticks to the main purpose of the analysis and does not include extraneous operations. Organized code has a clear order and direction. An outline is provided, and sections of the outline are clearly identified within the script. Throughout this book, we have tried, as far as possible, to satisfy this Abelson Principle. We also encourage the reader to do so as well. 1.5 Book layout At its core, the book is designed to satisfy one mighty constraint. Specifically, it aims to cover content that advanced students and instructors should - at least, hypothetically - be able to cover in a semester-length course (that’s roughly 14 weeks in the United States). Our strategy for satisfying this time-constraint is twofold. First, Part I provides a broad but shallow introduction to R. Consequently, readers are introduced to basic programming skills and given indications of where to look for more depth. For example, the book excludes any discussion of R Markdown, focusing instead on basic scripts as a tool for reproducibility. Conversely, Part II provides a deep but narrow introduction to introductory statistics. So, the text foregoes discussion of such things as ensemble modeling and dimensional reduction, opting instead to provide greater detail about probability distributions, significance tests, and multivariate models (both simple linear models and generalized linear models). This strategy also conforms to the pedagogy outlined above. 1.5.1 Chapter overviews At the beginning of each chapter, you will find a table with a chapter overview. These tables enable you to get a sense of what the chapter will cover at a glance. Here is the overview table for Chapter 6: R Basics: Goal To provide a brief overview of basic R functionality. tl;dr It’s a calculator. Outcomes Here, you will learn about what R is, why you should use it, and what a stereotypical workflow with it looks like. Datasets Palmer Penguins (Horst, Hill, and Gorman 2020) Requirements NONE Further Reading An Introduction to R (R Core Team 2020a)R FAQ (Hornik 2020) As you can see, it includes these six components: Goal. A short statement regarding the general lesson to be learned. tl;dr. Reddit-speak for “too long, didn’t read.” This provides a short summary description of the actual lesson. Outcomes. A numerical list of the specific skills and concepts you will learn. Data sets. The specific data you will need to run the R code used in the chapter. We try hard to provide citations for the data and links to web pages that provide more details. Requirements. A list of the skills and concepts you need to know already in order to follow along. Further Reading. Some suggestions regarding where one can look for more information about the chapter topic. Full citations are added at the end of each chapter. Where possible, links to the references are provided. 1.6 R code formatting In this section, we just want to touch briefly on two important formatting choices for R code. First, you will on occasion see inline code that looks like this: seq(2, 200, by = 2). This code is gray shaded and has a code font. We typically use this inline code when we want to refer to a specific object or function. For longer code sequences, including multiple object and function calls, we use code chunks that look like this: 1 + 1 ## [1] 2 Note, however, that on your own computer, the code that you run will look like this: &gt; 1 + 1 [1] 2 There are two big differences here. First, on your computer, but not in this book, code will always begin with the “prompt,” i.e., the greater-than symbol &gt;. Second, in this book, but not on your computer, the results of executing some bit of code will be commented out with two pound signs ##. These two differences facilitate copying code directly from the book and onto your computer. You will notice, too, that many of the code chunks in this book are littered with comments. These begin with a single pound sign #, for example, # hey look, I&#39;m a comment in R 1 + 1 ## [1] 2 These are provided in code chunks as a source of additional guidance, though we try to provide most of the explanation for what we are doing outside of the code chunk, in the primary flow of the prose. Throughout the book, we have also chosen to follow a consistent set of conventions for referring to R code proposed by Hadley Wickham and Garrett Grolemund in their R for Data Science book (see Chapter 1.5 Running R Code). These include: Referring to functions using code font and parantheses, e.g., mean() and seq(). Referring to function arguments using code font without parantheses, e.g., na.rm. Referring to R objects (like data and classes) using code font without parantheses, e.g., penguins and raster. Referring to packages using code font without parantheses, e.g., dplyr and mgcv. And, if we need to make it clear what package a function or dataset is from, we will refer to it using the package name and the function/data separated by two colons, e.g., dplyr::mutate() and palmerpenguins::penguins. (Using colons in this way is also proper R syntax.) 1.7 Exercises and data Chapter exercises are built on a separate platform, specifically Canvas, including all necessary data. Eventually, we hope to bundle the data and exercises into an R package. Unfortunately, that won’t be happening any time soon… References "],["r-and-rstudio.html", "Chapter 2 R and RStudio 2.1 What is R? 2.2 Why R? 2.3 RStudio", " Chapter 2 R and RStudio Figure 2.1: R in the wild. 2.1 What is R? R is variously described as a programming language for statistical computing and as a programming environment (Hornik 2020). In fact, if you use R to conduct any statistical analysis that will likely end up in a scientific publication, you will want to refer to it as such – to say something like “All analyses were conducted in the R Programming Environment” or “All analyses were conducted with the R Programming Language” – and then to cite it! For example, Statistical analysis was performed in R version 4.0.3 (R Core Team 2020b). And the full citation you can now see in the References below. 2.1.1 The R Environment According to the R Core Team (2020a), referring to R as an environment “is intended to characterize it as a fully planned and coherent system, rather than an incremental accretion of very specific and inflexible tools.” Now, on its face, this is a somewhat strange claim, as the word ‘environment’ would seem to suggest a physical surrounding composed of unplanned and incremental accretions. What is more, the R Programming Environment is not immune, as the quote would suggest, to constraints imposed by its history and evolution. Nowhere is this more apparent than in the myriad syntactic inconsistencies that have proliferated over the last 25 years of R’s development (Wickham 2015). Still, the word ‘environment’ is a good one, for R really is an environment that one can enter into, so to speak, and there do lots of very fun, very interesting, and very meaningful things, like complex data manipulations, fancy statistics, and data visualization (see Chapter 3 for an example workflow!). In this sense, you can think of it as a literal terminal or console on your computer that you type commands into. You can also think of the R environment as the place where the objects you make live and breath and have their being. In this sense, it is like a digital zoo or menagerie because the environment has (or should have, anyway) a lot more order to it than, say, a natural landscape unadulterated by human action. For more on the R environment, see Chapter 9: Workspace Management. 2.1.2 The R Language R is also a functional programming language (Hornik 2020) in the sense that it has a well-defined syntax and semantics, which together define rules for combining symbols into complex strings and interpreting their meaning. This is partially what they meant, I think, when the R Foundation described R as a “coherent system.” It is a coherent set of rules that govern the writing of code and its execution. I mean, you can’t just type anything into the R console and expect to get a result. For example, 5 - &quot;blargh!&quot; #### Error in 5 - &quot;blargh!&quot;: non-numeric argument to binary operator is just gibberish and as you see, R protests. But mean(1:5) ## [1] 3 is not. This string of symbols is simply requesting the mean of the numbers 1 through 5. R understands this and thus returns the desired output. 2.2 Why R? Actually, ‘R’ is a play on ‘S’, the name of the language R is based on, which John Chambers developed at Bell Labs in 1976. ‘R’ is also a reference to its authors, Ross Ihaka and Robert Gentleman, who began working on R at the University of Auckland in New Zealand, releasing it piecemeal into the digital wilds starting in 1993 (Hornik 2020). But, maybe you want to know why you should use R. Well… 2.2.1 It’s free! R is free software under the terms of the Free Software Foundation’s GNU General Public License. 2.2.2 It’s statistics made easy Using R lets you exploit the awesome computing powers of the modern world. Just try to do maximum likelihood estimation on, say, 10,000 observations of a half-dozen variables by hand. It is NOT worth it. But it is with R! And, what is more, R provides an elegant and concise syntax for writing these complex statistical operations. # fit a generalized linear model with a Gaussian error distribution to the data glm(formula = y ~ x1 + x2 + x3 + x4 + x5, family = gaussian, data = my_ten_thousand_observations) 2.2.3 It’s pretty figures One of the most powerful features of R is its ability to produce publication-quality plots. For instance, R’s native graphics engine allows you to plot this normal distribution: #### Error in windowsFonts(A = windowsFont(&quot;Arial&quot;)): could not find function &quot;windowsFonts&quot; 2.2.4 It’s reproducible R also facilitates reproducible research. It does this in two ways. First, it forces you to declare explicitly each step in your analysis. set.seed(12345) my_data &lt;- sample(1:1000, size = 100) mu &lt;- mean(my_data) std_dev &lt;- sd(my_data) We see here that someone has set the seed for R’s random number generator, sampled one hundred numbers between 1 and 1000, then taken the mean of that sample and its standard deviation. Everyone can now see this process and repeat it verbatim for themselves. Crucially, everyone also includes future-you, that stranger who might one day look back and wonder, “How did I do this?” The second way that R promotes reproducible research is by making R code like this shareable. In the simplest case, we use R scripts, which are text-based files containing R code that you or someone else with an R installation can run. Alternatively, we can use R Markdown, a much more flexible tool for not only writing and saving R code, but for explaining in detail what you are doing alongside the code itself. 2.2.5 It’s an active community R is also an incredibly active and growing community, with lots of rich and informative documentation, and forums where one can go to get help trouble-shooting problems. There are a lot of ways to visualize this idea, but here is one, the number of downloads of R from the online RStudio CRAN mirror (not necessary to know what that is) from 2015 to the present. 2.3 RStudio If you are going to do anything with R, RStudio is hands-down the best place to do it. RStudio is an open-source integrated development environment (or IDE) that makes programming in R simpler, more efficient, and most importantly, more reproducible. Some of its more user-friendly features are syntax highlighting (it displays code in different colors depending on what it is or does, which makes it easier for you to navigate the code that you’ve written), code completion (it will try to guess what code you are attempting to write and write it for you), and keyboard shortcuts for the more repetitive tasks. By far, though, the best feature RStudio offers is a customizable workbench or visual interface for R programming (described in the next section). 2.3.1 Pane layout When you first open RStudio, you should see three window panes: the Console, the Environment, and the Viewer. If you open an R script, a fourth Source pane will also open. The default layout of these panes is shown in Figure 2.2. Figure 2.2: RStudio Default Four Pane Layout Source. The Source pane provides basic text editing functionality, allowing you to create and edit R scripts. To open an R script in RStudio, just click the green and white plus-sign button displayed below File and select “R Script.” Note that you can also achieve this by using the RStudio keyboard shortcut Ctrl+Shift+N. Importantly, you cannot execute the code in these scripts directly, but you can save the scripts that you write as simple text files. A dead give away that you have an R script living on your computer is the .R extension, for example, my_script.R. For some directions on how to properly format your R scripts and code to make them more human-readable, see Chapter 5: R Style Guide. For more on how to use R scripts, specifically how to execute the code they contain, see Chapter 6: R Basics. Console. The Console pane, as its name suggests, provides an interface to the R console, which is where your code actually gets run. While you can type R code directly into the console, you can’t save the R code you write here into an R script like you can with the Source editor. That means you should reserve the console for non-essential tasks, meaning tasks that are not required to replicate your results. For more on the R console, see Chapter 6: R Basics. Environment. The Environment pane is sort of like a census of your digital zoo, providing a list of its denizens, i.e., the objects that you have created during your session. This pane also has the History tab, which shows the R code you have sent to the console in the order that you sent it. Viewer. The Viewer pane is a bit of a catch-all in terms of its functionality, though I suspect the primary use you will make of it is to view the graphical output of your R code, hence calling it the Viewer pane. At any rate, the four tabs most relevant for the topics discussed in this book are the Files tab, the Plots tab, the Help tab, and the Viewer tab. The Files tab works like a file explorer. You can use it to navigate through folders and directories. By default, it is set to your working directory. The Plots tab displays any figures you make with R. The Help tab is where you can go to find helpful R documentation, including function pages and vignettes. For more on how to access help documentation and other sources of R support, see Chapter 4: Looking for Help. The actual Viewer tab provides a window to visualize R Markdown (anything generated by knitr, really) and Shiny output. References "],["example-workflow.html", "Chapter 3 An Example Workflow 3.1 In fits and starts 3.2 The whole shebang", " Chapter 3 An Example Workflow Figure 3.1: An idealized workflow in R 3.1 In fits and starts To give you a feel for what all can be done with R, let’s walk through an example workflow, as shown in Fig. 3.1. This typically involves importing data, reshaping and/or subsetting it to get it into a format necessary for analysis, doing some preliminary descriptive statistics to explore general properties of the data, doing some inferential statistics to investigate trends in the data, and summarizing the results of the analysis. At various stages, visualizing the data will be extremely helpful, either to explore the data further or to help communicate the results to others. A lot of the output of this process, we will also want to save for later, perhaps to include in a publication (like a figure or model summary), but maybe also to avoid repetition of difficult and time-consuming tasks. Now, obviously, the diagram in Figure 3.1 is meant to give you a feel for what a typical workflow should look like, at least ideally. As you can see, it is very austere and organized, almost linear, with cool, pleasant colors. You might even call it inviting. Do not be fooled, however. For what you will actually encounter with your work will often look like this: Figure 3.2: The often circuitous and sometimes painful maze of statistical analysis in R. The path traversed through the maze in this figure has a disorienting, almost chaotic, feel to it.3 It suggests - correctly - that statistical programming involves lots and lots of false starts, dead-ends, and backtracking. Frankly, there’s no avoiding these frustrations, but that’s not because what you’re doing is statistical programming per se, but rather just writing to express ideas. And, like any writing exercise, you start with a blank page, add content here or there, and then, you know, revise, revise, revise, until you get something sufficiently polished that it conveys its intended meaning well. So, as I walk through this example workflow, maybe think about the idealized diagram more as a representation of your final (or final-ish4) draft (“script,” in code talk), and then the maze is just the frustrating, though ultimately rewarding, write-and-revise path to get there. 3.2 The whole shebang 3.2.1 Load data penguins &lt;- read.csv(&quot;penguins.csv&quot;) head(penguins) ## species island bill_length_mm flipper_length_mm body_mass_g sex year ## 1 Adelie Torgersen 39.1 181 3750 male 2007 ## 2 Adelie Torgersen 39.5 186 3800 female 2007 ## 3 Adelie Torgersen 40.3 195 3250 female 2007 ## 4 Adelie Torgersen NA NA NA &lt;NA&gt; 2007 ## 5 Adelie Torgersen 36.7 193 3450 female 2007 ## 6 Adelie Torgersen 39.3 190 3650 male 2007 3.2.2 Do grunt work Are observations of bill length missing for any penguins in this dataset? To answer this question, we can check for NA values. And if we really need that information, we can exclude those penguins from our analysis. any(is.na(penguins$bill_length_mm)) ## [1] TRUE penguins &lt;- subset(penguins, !is.na(bill_length_mm)) The exclamation point ! (often called “bang”) means “not,” so you can read that second line as “subset the penguins table and give me the rows that do not have NA values for bill length.” Now, before moving on to the fun stuff, we might want to ask a few preliminary questions of our data. How many penguins are on each island? counts &lt;- table(penguins$island) counts ## ## Biscoe Dream Torgersen ## 167 124 51 What does this distribution look like? barplot(counts) What is the mean bill length for each species? aggregate(bill_length_mm ~ species, FUN = mean, data = penguins) ## species bill_length_mm ## 1 Adelie 38.79139 ## 2 Chinstrap 48.83382 ## 3 Gentoo 47.50488 And the standard deviation? aggregate(bill_length_mm ~ species, FUN = sd, data = penguins) ## species bill_length_mm ## 1 Adelie 2.663405 ## 2 Chinstrap 3.339256 ## 3 Gentoo 3.081857 How is bill length distributed across species? boxplot(bill_length_mm ~ species, data = penguins, xlab = &quot;Species&quot;, ylab = &quot;Bill Length (mm)&quot;) 3.2.3 Do fun stuff penguin_model &lt;- lm(flipper_length_mm ~ bill_length_mm, data = penguins) summary(penguin_model) ## ## Call: ## lm(formula = flipper_length_mm ~ bill_length_mm, data = penguins) ## ## Residuals: ## Min 1Q Median 3Q Max ## -43.708 -7.896 0.664 8.650 21.179 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 126.6844 4.6651 27.16 &lt;2e-16 *** ## bill_length_mm 1.6901 0.1054 16.03 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 10.63 on 340 degrees of freedom ## Multiple R-squared: 0.4306, Adjusted R-squared: 0.4289 ## F-statistic: 257.1 on 1 and 340 DF, p-value: &lt; 2.2e-16 Estimate flipper length using penguin_model. est_flipper_length &lt;- predict(penguin_model) obs_flipper_length &lt;- penguins$flipper_length_mm obs_bill_length &lt;- penguins$bill_length_mm Plot the estimated trend against the observed values: plot(obs_flipper_length ~ obs_bill_length, pch = 19, cex = 1.3, col = alpha(&quot;#949494&quot;, 0.4), xlab = &quot;Bill Length (mm)&quot;, ylab = &quot;Flipper Length (mm)&quot;) abline(penguin_model, col = &quot;#850000&quot;) mtext(text = &quot;Palmer Penguin Model&quot;, side = 3, line = 0.3, adj = 0, cex = 1.5) 3.2.4 Export results Save the cleaned data and the linear model.5 write.csv(penguins, &quot;penguins.csv&quot;, row.names = FALSE) save(penguin_model, file = &quot;penguin_model.Rdata&quot;) And that’s it! It should, anyway, because it’s a random walk.↩︎ Can we really speak of final drafts in this digital age?↩︎ Saving a figure in base R is a bit tricky, so we will leave that lesson for another time.↩︎ "],["looking-for-help.html", "Chapter 4 Looking for Help 4.1 The Google Search Paradox 4.2 Helpful helpers 4.3 Reproducible examples", " Chapter 4 Looking for Help Figure 4.1: Wisdom of the Ancients (xkcd 979). 4.1 The Google Search Paradox As you make your first tentative forays into the R programming environment, you will on occasion experience the jarring dislocation of an R error, a typically bright red eruption of your R console, perhaps symbolic of your code exploding before your eyes. Here is one of the more infamous errors you are likely to encounter: object of type ‘closure’ is not subsettable Nevermind what this particular error means.6 The point is that it can be terribly frustrating when you encounter it or one of its kin. Often troubleshooting these errors can be an additional source of anxiety and frustration, especially early on, as you simply lack the words required to describe your problem accurately and, thus, to formulate the question whose answer you so desperately need. I like to refer to this unhappy circumstance as the Google Search Paradox because you will inevitably find yourself staring at that cursed blinking cursor in the search bar, wondering what words to give to Google. It’s also a bit like Meno’s Paradox, or the Paradox of Inquiry. For if you could properly frame your question, it’s probably the case that you already know the answer. So, you either know and thus don’t need to ask, or need to ask, but don’t know how. Of course, the situation is not nearly so dire as this. In truth, you always know at least a little about your problem - you do have the error itself after all! - and can thus Google your way through to an answer - eventually, anyway. But life is fleeting, as they say, and time is short, so you should probably avoid the brute force approach, relying instead on searching efficiently. To help you with that (and to help you get better with that), this chapter provides a brief annotated list of where to look for answers, starting from within R itself! 4.2 Helpful helpers 4.2.1 R Typically, though not always, R code will have lots of supporting documentation. These come in two varieties. We’ll call them short-form and long-form documentation. The former is typically geared toward specific functions and object classes, with definitions of code components and examples of how to use them. Long-form documentation (also referred to as “vignettes”) goes over code usage and examples in greater detail. If you are having trouble specifying some particular component of your code and you know what that component is, you may find the short-form documentation more helpful. If you are having trouble getting through some analysis and you cannot pinpoint the exact reason for your trouble, the vignettes are probably where you should look. In general, though, you should think of these two forms of R documentation as the first stop along the way to troubleshooting your code. There are a couple of ways to access this documentation. From within R, you can use the help() and ?... functions to access short-form documentation. Examples include help(\"plot\") and ?plot. This will call up the function’s documentation page and display it in your computer’s graphical device. All R functions have a similar page, which provides a brief description of the function, the parameters that it takes and how these change the way it works. It is also worth scrolling down - at the bottom of the help page will be some examples of usage which you can run to get a feel for how the function works. help.search(...) and ??... both provide means of searching through help pages to find multiple functions with the same name (and potentially the same or similar uses). Simply replace the ellipses (three dots) with a character string and these functions will return all help pages with that string. So if you want to carry out a cluster analysis, typing ??cluster will search for any functions that use the word cluster; hopefully, including some that are relevant to cluster analysis. There are two very useful websites that host short-form R documentation. Those are rdrr.io and rdocumentation.org. If you Google an R function, links to its documentation on these websites are typically the first that you will see. For the best search results, I recommend Googling “R &lt;package name&gt; &lt;function name&gt;.” From within R, you can also access the long-form documentation using some combination of vignette(), browseVignettes(), and RShowDoc(). (Note that if you want to know what these functions do, you can also use, for example, help(\"vignettes\")). The function vignette() with no argument specified will bring up a list of all available long-form documents or vignettes, organized by package. If you want the vignettes for a particular R package, you can also type vignette(package = ...), for example, vignette(package = \"grid\") will bring up the vignettes for the grid package. browseVignettes() will open a locally hosted HTML page in your browser with links to all available R vignettes. This is actually quite helpful, and you should give it a try when you get a chance. Just browsing through these vignettes will give you a great feel for all that you can do in R. RShowDoc() is mostly for opening a single vignette (either as a PDF in your viewport or as an HTML page in your browser, depending on what is available). This is usefully paired with vignette(), which will give you the name of the vignette and package, so that you can, for example, call RShowDoc(what = \"plotExample\", package = \"grid\"). This will bring up the “plotExample” vignette from the grid package. Package authors have lots of resources for sharing their documentation now, including websites designed specifically to present both short- and long-form pages. Here is an example of the website for the colorspace package. Finally, you can access all available documentation (short- and long-form) for official R packages by navigating the Comprehensive R Archive Network (CRAN) website, here: https://cran.r-project.org/. 4.2.2 RStudio While RStudio provides loads of support to R users, here we mention some of the more important ones. RStudio How To Articles provide loads of how-to guides for working with R and RStudio. This is a very comprehensive suite of useful documentation. RStudio Cheatsheets strive to communicate short- and long-form documentation together in a single, concise poster format with lots of visual queues and simple definitions. These can be really helpful when you need a quick refresher on the use of some bit of code. RStudio Community is an online forum where individuals ask and answer questions about R and RStudio. They have a very strict code of conduct for their members that emphasizes mutual respect and inclusivity, so you will generally find the discussions here much more friendly and supportive. Use of this forum is highly recommended. RStudio Education is a very, very recent development by RStudio (it came online in 2020), and it is simply amazing as a resource for not only learning R itself, but also learning how to teach R. Please note that, with the exception of number 4, these RStudio help tools can be accessed within the RStudio IDE under the Help tab. 4.2.3 R Community The R community refers to R users who are actively communicating with and supporting other R users. As there are lots and lots of engaged R users these days, and more and more every day, the community is definitely thriving. There is also an expanding ethos within this community driven largely by RStudio and its code of conduct, so you will generally find R users to be a friendly bunch (if a little hoity-toity; plus, there’s always the bad apple). So, let’s talk about where you can engage with this community. We have already mentioned one, RStudio Community, but here we will list some more. Stack Overflow is a forum for programmers in all programming languages to ask and answer questions, much like RStudio Community. It’s just been around longer (2008 to be exact), which means its code of conduct has evolved over time to address a number of unanticipated issues. The consequence is that answers to questions will run the gamut from being respectful and clear to downright insulting. Still, it is a rich resource for addressing your R coding issues. And it has gotten a lot better. ROpenSci is an R programming community focused on promoting open and reproducible research in science. They have a forum much like RStudio Community, a blog with helpful news and overviews of the packages in their ecosystem, and a rich suite of webpages for their supported R packages, which you can explore here. R-bloggers is a clearinghouse for R related content, basically an aggregator of content from individual blogs. It is worth perusing every now and then to pick up the occasional gem of R understanding. The #rstats Twitter community is something. Use this if you use Twitter, I guess… The rstats subreddit is a helpful community of Redditors that are pretty good about answering questions you might have. Though do not go there asking them to do your homework for you! 4.2.4 Other Resources The UCLA Institute for Digital Research &amp; Education offers Statistical Consulting geared toward R. This is a tremendous resource for both R and statistics and is highly recommended. 4.3 Reproducible examples Others have likely asked the same question you want to ask, so you will not always need to go online, to a forum or what-have-you, and make a post yourself. But, in the off chance that you do find yourself confronted with a question never asked before, you need to make sure you provide R users with all the information and resources they need to help troubleshoot your code. This involves providing a “reproducible example” or reprex. There are two essential ingredients to a reprex: It needs to be reproducible. It might not seem obvious, but you need to make sure you provide everything needed to reproduce your error as is, for instance, all library() calls in your code. It needs to be minimal. In other words, do not include anything extraneous or burdensome, like a 400 MB data object. A much smaller R object should suffice. A lot has been written about how to put together a reprex, so rather than belabor the point here, it is perhaps best to direct you to Jenny Bryan’s reprex package, which will walk you through the process of submitting a help request on the various forums mentioned above. Though check out Jenny Bryan’s talk at the 2020 RStudio Conference: https://rstudio.com/resources/rstudioconf-2020/object-of-type-closure-is-not-subsettable/↩︎ "],["r-style-guide.html", "Chapter 5 R Style Guide 5.1 Abelson again 5.2 Be verbose! 5.3 Don’t Repeat Yourself (DRY) 5.4 Assignment first 5.5 The Cratylus Rule 5.6 Empty nests! 5.7 Be open 5.8 Be organized", " Chapter 5 R Style Guide Figure 5.1: O.P.C. (Abstruse Goose 432) 5.1 Abelson again When writing code, you should always have an eye to ensuring that it is both clear and intelligible for anyone who might come along and read it. This will ensure that your code is reproducible, which is especially important if what you are doing with R is scientific analysis. It is also just of practical value, for you will most assuredly want to reuse your code at some point in the future, or apply it to a different data set, but if you can’t make heads or tails of it, well… The following styling rules-of-thumb are inspired by the Tidyverse style guide, with a focus on those that are more relevant to beginning R coders. These rules we have tried to follow throughout this book. 5.2 Be verbose! One way to make your code clearer is to make it more verbose. Obviously, this isn’t a recommendation to include long-winded, self-indulgent soliloquies in your code. Rather, the suggestion is that you not shy away from being explicit, even if - horror of horrors! - it takes you an extra second or two to do. In other words, don’t leave it up to the reader to guess what you’re doing. Verbosity in this sense can be applied to three aspects of R code: i) object names, ii) function parameters (or arguments), and iii) coding comments. 5.2.1 Object names An old-school coding norm encouraged programmers to write highly compact code with loads of abbreviations. In general, however, you should avoid this, at least when it’s reasonable to do so. # Good mean_height &lt;- mean(height) # Bad mh &lt;- mean(height) # But, mean_height_of_actors_who_auditioned_for_aragorn &lt;- mean(height) # is overkill If the abbreviation is something obvious, though, like “USA” or “IHOP,” you should feel free to use it. 5.2.2 Function parameters When you call a function, you typically supply it with i) a data object, which the function is going to do something with, and then ii) a list of arguments, which specify how exactly the function will work with the data. You can avoid specifying the argument name for the data object, but you should strive to use the names of any arguments you override. # Good bob &lt;- mean(1:5, na.rm = TRUE) # Bad bob &lt;- mean(1:5, TRUE) 5.2.3 Code commenting Looks like some people get really worked up about this one, but just keep this in mind. Anyone reading your code should ideally be able to understand what it is doing without comments, but this frankly is not always possible (for example, for students who are first learning R!). This means you should typically keep comments to a minimum and only use them when you think it would help someone to understand not just what you are doing, but why you are doing it. 5.3 Don’t Repeat Yourself (DRY) Also known as the DRY Principle. If you find yourself copying the same code multiple times - say, three or more times a session, this is a good indication that you should write a function instead. 5.4 Assignment first Technically, R allows you to use a right-facing arrow, -&gt;, for assignment. You can also use the equal sign, =. However, even though these are allowed by R, they make your code harder to read and - at least in the latter case - ambiguous. So, you should always use the left-facing arrow, &lt;-, for assignment # Good bob &lt;- 5.137 # Bad 5.137 -&gt; bob # Ambiguous bob = 5.137 5.5 The Cratylus Rule This rule requires that a name reflect the nature of the thing named. Because objects are things and functions do things, the Cratylus Rule suggests that you should use nouns as names for R objects and verbs as names for R functions. numbers &lt;- 1:10 add_one &lt;- function(x) x + 1 5.6 Empty nests! Nesting in R is the act of calling one function inside the call to another function, like rnorm(sample(seq(1, 1000, 2)+3)). This is OK for shallow nests, meaning a function call in a function call, at least when used sparingly, but you should avoid deep nests, or a function call in a function call in a function call in…, you get the idea. In general, deep nests make your code really, really hard to read, so instead, you should assign the results of the inner functions to intermediate objects and then use those objects in the outer functions. # Bad sort(rnorm(100, mean = mean(sample(seq(1, 1000, 2), 50)))) # Good samples &lt;- sample(seq(1, 1000, 2), 50) randos &lt;- rnorm(100, mean = mean(samples)) result &lt;- sort(randos) 5.7 Be open In general, lots of white space makes it easier to read and comprehend just about any string of text, whether in books, articles, or R scripts! 5.7.1 Spacing Use lots of spaces in your code, just as you would with regular texts. That means spaces after commas, spaces around the assignment operator &lt;-, and spaces around the equal sign = in your function call. # Good bob &lt;- mean(1:5, na.rm = TRUE) # Bad bob&lt;-mean(1:5,na.rm=TRUE) 5.7.2 Line Length Think of your R script as having a giant cliff somewhere in the middle, right around 80 characters. And your job is to never go full Wiley E. Coyote with your code! Instead, return and start a new line. # Good bob &lt;- glm(y ~ x, family = gaussian, data = my_ten_thousand_observations) # Bad bob &lt;- glm(y ~ x, family = gaussian, data = my_ten_thousand_observations) 5.8 Be organized You should use commenting to give your script structure that makes it easier to navigate and to understand its intent. Intuitively, providing structure to your R script is a lot like providing structure to a term paper or a thesis. Title. You will want to include a title that indicates the aim or goal of the script, the date you wrote the script, the author(s), and where necessary, any additional notes about the intent of the script or its status. Sections. If the script is sufficiently long or complex, you will also want to carve it into named sections using section headers. Outline. If you have a lot of those sections, you might also consider adding an outline section at the beginning. Preamble. Very importantly, make sure to include an R “preamble” section where you attach all the R packages you are using, define any global options you might want to recycle throughout the script, and then source any helper functions you might want to use. # Aim: What should the script achieve # Date: 2020-01-13 # Author(s): Blake, Thor, Spiderman # Note(s): # 1. Make sure to pick up more toothpaste at the store. # OUTLINE ----------------------------------------------- # 1. R PREAMBLE # 2. IMPORT DATA # 3. EXPLORE DATA # 4. ... # 1 R PREAMBLE ------------------------------------------ # attach packages library(dplyr) library(sf) # define global options proj_crs &lt;- st_crs(26912) # source functions source(&quot;plot_helpers.R&quot;) # 2 IMPORT DATA ----------------------------------------- nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package = &quot;sf&quot;)) # 3 EXPLORE DATA ---------------------------------------- "],["r-basics.html", "Chapter 6 R Basics 6.1 Overview 6.2 A Glorified Calculator? 6.3 Console and Scripts 6.4 Objects and Functions 6.5 Packages in the R Library", " Chapter 6 R Basics 6.1 Overview Goal To provide a brief overview of basic R functionality. tl;dr It’s a calculator. Outcomes Here, you will learn about what R is, why you should use it, and what a stereotypical workflow with it looks like. Datasets Palmer Penguins (Horst, Hill, and Gorman 2020) Requirements NONE Further Reading An Introduction to R (R Core Team 2020a)R FAQ (Hornik 2020) 6.2 A Glorified Calculator? R has functionality for basic arithmetic operations, including + addition, - subtraction, * multiplication, / division, and ^ exponentiation. 3+2 ## [1] 5 3-2 ## [1] 1 3*2 ## [1] 6 3/2 ## [1] 1.5 3^2 ## [1] 9 6.3 Console and Scripts In this section, we’ll go over some basic considerations of where to write your R code and where to run it. 6.3.1 R Console Perhaps this is obvious, but you can write R code basically anywhere - on a napkin at a restaurant, for instance, on your hand in a pinch, or even in a fever dream - but if you want to get your R code to actually run, you will have to send it to the R console, so it can be interpreted. In this sense, at least, the R console is like R’s central nervous system. Signals (your code) get sent to the console to get interpreted and generate some behavioral output (like a plot or a linear model). Here is what typing R code in the actual R console looks like: Please note that in this book, the greater-than symbol &gt; preceding R code is suppressed, and that the result is preceded by ##. 6.3.2 R Scripts One important downside of writing R code directly into the console is that it is more like writing R in a dream than on a restaurant napkin. When you write code into it, you cannot get it back once you “wake up” from your R session.7 This means that working in the console subjects the reproducibility of your analysis to the sometimes (often?) unreliable testimony of your own memory - like trying to remember what happened in your dream. To overcome this limitation of the console, the authors of R have also provided a specially designed text file, called an R “script,” that you can write R code into and save to disc. A dead giveaway that you have one on your computer is the .R file extension. Note, however, that even with R scripts, you cannot just open one in a text editor and expect the code it contains to run. You would be just as well off wadding up your napkin of code and hurling it defiantly at your monitor. No, to get your code to run, wherever it resides, you must always pass it to the console to get interpreted. There are a number of ways to do this, the most basic being these: Copy and paste the code from your script into the console. This strategy, of course, makes an R script only slightly more advantageous than a napkin… To run a single line of code, place the cursor on that line and hit CTRL+Enter on PC or CMD+Enter on Mac. To run multiple lines of code, highlight those lines and hit CTRL+Enter (CMD+Enter). 6.4 Objects and Functions In R, you can make things and you can do things. The things that you make are called objects and the things that you do things with are called functions. The most common kind of R object is a vector. You can learn more about the different types of vectors in Chapter 6 The R Menagerie. Other kinds of objects include formula, raster, grob, hist, and density. What about functions? These are actually a special class of object that take other objects as input and typically (though not always) return other objects as output.8 They are thus “functions” in the sense of input-output devices. Any complex statistical operation you want to conduct in R will almost certainly involve the use of one or more functions. 6.4.1 Creating objects with assignment How do you make an object in R? Well, you just… bob &lt;- 5.137 It’s that simple! Or, maybe not. Let’s take a moment to unpack this black magic. First, we note that it is made-up of three things: a name, in this case, bob; an arrow, &lt;-, the essential ingredient in this incantation; and an object, specifically the number 5.137, which is being created. Basically, what is happening here is that the statement adds an object (5.137) to the R environment and then assigns that object to the name bob. This is why it is sometimes referred to as an assignment statement (R Core Team 2020a). It is not just creating an object, but assigning it to a name. R has a few syntactic requirements for object names. They can only contain letters, numbers, underscores _, and periods . (or dots). And they cannot start with numbers. # Good winter_solder &lt;- &quot;Buckey&quot; object4 &lt;- 23.2 # Bad winter soldier &lt;- &quot;Buckey&quot; # spaces not allowed 4object &lt;- 23.2 # cannot start with a number R is case sensitive! So, R will not treat My_naME and my_name the same. But enough of that, why assign a name at all? Well, if we just typed 5.137 the resulting object would live a fleeting life, shorter than a fruit fly’s, being quickly created and just as quickly destroyed. But, when we give an object a name, we also give it some permanence, and can literally call it back whenever we like. We just say, “bob, come here!” but in the language of R: print(bob) ## [1] 5.137 or even just bob ## [1] 5.137 And then R summons bob for us and tells us who bob is. bob is 5.137. Obviously! Now, you may think, “I could just create 5.137 any time I wanted, let it die, and just create it again. It’s not that hard to type five characters, after all.” If you want to flirt with anarchy in this way, by all means, but let me offer two good reasons why you shouldn’t. First, it is certainly true that one number is not hard to type, but it is rare that you will need just one. Suppose you had an object consisting of ten thousand numbers, would you care to type that each time you needed it? For that matter, it would be nigh impossible to ensure you were typing the same numbers each time. Plus, when you make an object with a name, R has your back. If you type 6.137 instead of 5.137, for example, R will not protest, but if you type boo instead of bob, R will say, “nope.” 6.137 ## [1] 6.137 boo #### Error in eval(expr, envir, enclos): object &#39;boo&#39; not found So, giving objects names in R is a good way to avoid errors. 6.4.2 Doing things with functions To use a function, we call it just as we would any other object, by typing its name. Unlike simple objects, though, we must also take care to append closed parentheses () to the end of the function name. Within those parentheses, we can go on to supply arguments that control how the function behaves. function_name(arg1 = value1, arg2 = value2, ...) # for example seq(1, 5, length.out = 100) If you cast your mind back to the algebra you learned in high school, this syntax should be familiar to you. Consider this algebraic expression: \\[ f(x) = 2x + 3 \\] The name of this function is \\(f\\). Its arguments include \\(x\\). And the object it returns is the result of multiplying \\(x\\) by 2 and adding 3. So, if you supply this function with the value 4 (as in, \\(f(x=4)\\)), it will return 11 as a result. R functions work in precisely the same way. Sometimes you just want to see the result of a function call, as it may suggest the next steps in your analysis. Other times, however - for instance, if you believe that you will need the result of your function call to feed as input to some other function, you should probably assign the result to a new name. mu &lt;- mean(1:5) seq(1, mu, length.out = 5) ## [1] 1.0 1.5 2.0 2.5 3.0 6.5 Packages in the R Library References "],["statistical-graphics.html", "Chapter 7 Statistical Graphics 7.1 Overview 7.2 Plot Anatomy 7.3 The plot() Function 7.4 Layering 7.5 Annotation 7.6 Graphical Parameters 7.7 Multi-plot Layouts", " Chapter 7 Statistical Graphics 7.1 Overview Goal To introduce students to the fundamentals of data visualization using the base R plotting system. tl;dr Let the data speak. Let the data speak pretty. Outcomes Here, you will learn about the anatomy of a base R plot the plot() function, layering, annotation, graphical parameters, and multi-plot layouts. Datasets Palmer Penguins (Horst, Hill, and Gorman 2020)General Social Survey (Bray et al. 2020) Requirements NONE Further Reading An Introduction to R (R Core Team 2020a)R Graphics (2nd Ed) (Murrell 2018)R Graphics Cookbook (2nd Ed) (Chang 2019) In statistics, graphics provide visual representations of data, but why might we want to visualize data? To answer this question, we might consider a common distinction between three modes of data visualization: exploration, analysis, and presentation. Visual exploration is part and parcel of what John Tukey (1977) referred to as “exploratory data analysis” (cf Peng 2016; Tufte 2006). With it, we can (i) investigate the distribution of observations around some measure of central tendency (like the mean or median) or evaluate relationships between variables; (ii) detect problems with our data, like outliers, missing values, or other anomalies; and (iii) generate questions we may not have considered otherwise. Visual analysis, as its name suggests, is largely concerned with the statistical analyses we are conducting to answer our primary research questions. It involves such things as direct hypothesis testing, as well as evaluation of the results of statistical analyses, usually to see if the results are actually meaningful, even sometimes finding patterns that may have been missed or over-interpreted. Visual presentation is largely aimed at reporting findings to others, whether about the data itself or the results of analyses conducted with the data. Of course, the intended audience is often other scientists and researchers, but it does not have to be. Informing the public about your research is also important, and having nice graphics is a really good way of doing that. Here we are focusing on the basics of visual exploration using R’s native graphics tools, though much of what you learn here will apply more generally to visual presentation too. 7.2 Plot Anatomy Producing statistical graphics in R is a lot like adding layers to a canvas. To setup a canvas and to add some default layering, we use the plot() function. This is a programming workhorse in R, used routinely and repeatedly during R sessions. Before diving into its use, though, let’s first step back to, as it were, dissect a base R plot, getting a feel for its general structure or anatomy (Fig. 7.1). In effect, this means getting a feel for the hidden layout of a plot canvas. Hopefully, this will provide you a better sense of what you are doing when, for example, you feed your plot this parameter xlim = c(0, 1). Figure 7.1: Base R plot anatomy 7.2.1 Region The plot region is the area in which geometries (like points, lines, and polygons) provide visual representations of data. Particular locations within the plot region are specified using a two-dimensional coordinate grid, the coordinates being denoted by convention as ‘x’ and ‘y’. Around the plot region, R defaults to including a plot box (represented by the light gray square in Fig. 7.1). 7.2.2 Sides The plot region is rectangular, so, naturally, it has four sides. R uses a number to refer to each side. 1 = bottom 2 = left 3 = top 4 = right Knowing how to refer to sides will allow you to control the position of other plot elements, like axes, for example. 7.2.3 Axes The scope of the plot region is defined by the x and y axes (represented by the thick orange lines), which specify the upper and lower limits of the observations to include in the plot. In Fig. 7.1, the limits are (0, 1) for both x and y. You may notice that the axes do not meet at the origin (0, 0). This is because R by default includes some padding above and below the specified limits. The most important elements of plot axes are breaks, tick marks, and tick labels. Tick marks provide a visual reference for how observations are arrayed within the plot region and are represented by short dashes emanating from each axis line. Breaks are specific values within the limits of an axis at which tick marks are displayed. By default, the breaks include the limits themselves. Ideally, break values are used as tick labels, though if you really wanted to confuse someone, including yourself, you can give them other labels as well. 7.2.4 Titles Every R plot includes four titles, the main title, the subtitle, and a title for each axis. One somewhat strange design choice on the part of the R Core Team was to place the subtitle below the x-axis title. It appears they meant the ‘sub’ in ‘subtitle’ quite literally… 7.2.5 Margins One of the more complicated features of the base R anatomy is margins. For every plot, there are two sets of these: the inner (or figure) margins and the outer margins. The inner margin (represented by the dark red box) is the area immediately surrounding the plot region, which typically involves plot titles and axis labels. The outer margin (represented by the dark blue box) is an area of additional space around the inner margin. Fiddling with the outer margin is not particularly useful in most contexts, unless you want to have multiple plot regions in one figure (discussed below in the Plot Layout section). The area of the margins is defined by “Lines,” named starting with 0. By default, the inner margin is four lines in width (Line 0 to Line 3) and the outer margin is three lines in width. These lines may be used to position other plot elements, including, more often than not, plot titles. Note that R does not include the outer margin by default. It must be added explicitly using Graphical Parameters (see below). 7.2.6 Legend A legend or key provides a list of additional variables represented by symbols or colors in the plot region, along with the symbols or colors used. By default, R includes the legend within the plot region, but it is possible to move it to the inner or outer margin. 7.3 The plot() Function The base plot() function is a generic function, meaning it will produce different results depending on what kind of R object you are asking it to draw. At its core, though, the plot() function is simply a tool for mapping data onto a grid (the plot region in Fig. 7.1). Consider, for example, these values of x and y. x &lt;- c(0.0, 0.2, 0.3, 0.5, 0.6, 0.8) y &lt;- c(0.9, 0.8, 0.6, 0.5, 0.3, 0.1) When you supply plot() with these values, it maps them to a grid like so. Figure 7.2: Mapping data onto a grid. There are two ways to supply the plot() function with these x and y values: (i) as separate vectors or (ii) as a combined formula. As separate vectors plot(x, y) As a combined formula plot(y ~ x) Notice the tilde, ~. This may be read as “… is a function of …”, in this case “y is a function of x.” You should use the formula notation whenever plotting a relationship between two variables, as it makes it explicit in your code that you are plotting that relationship. By default, plot() provides for nine different types of plot. These are specified using the argument type. Options include all of the following: \"p\" (points), \"l\" (lines), \"b\" (both points and lines), \"c\" (lines with missing points), \"o\" (points plotted over lines), \"s\" (stair steps), \"S\" (stair steps inverted), \"h\" (histogram-like vertical lines), \"n\" (nothing). So, if you want to plot points, for instance, you would type plot(y ~ x, type = &quot;p&quot;) And just so you can see the result, here are examples of each: Figure 7.3: Default plot types. One of the most important features of a plot is its limits. By default, plot() uses the range of the x and y vectors. In this case, the range of x is [0, 0.8] and the range of y is [0.1, 0.9]. You will perhaps have noticed, however, that the limits in Figures 7.2 and 7.3 are [0, 1]. That is because we supplied plot() with these values using the arguments xlim and ylim. plot(y ~ x, xlim = c(0, 1), ylim = c(0, 1), xlab = &quot;X&quot;, ylab = &quot;Y&quot;) Individuals (especially those with a chaotic-evil alignment) may abuse plot limits to obscure or exaggerate features of their data. You see, for example, in our toy data that the points have a certain trend starting in the upper left corner of the plot and falling to the lower right corner. What do you think would happen to the look of that trend, though, if we were to specify new limits for y, say [0, 100]? 7.4 Layering Whenever you use plot(), it establishes a new “canvas” and provides some default plot elements (specifically x and y axis titles, a box around the plot region, and tick marks and labels). These can all be “turned off,” so that plot() simply establishes an empty canvas. plot(y ~ x, type = &quot;n&quot;, xaxt = &quot;n&quot;, # remove the x-axis yaxt = &quot;n&quot;, # remove the y-axis xlab = &quot;&quot;, # remove x-axis title ylab = &quot;&quot;, # remove y-axis title frame.plot = FALSE) # remove the box around the plot region Figure 7.4: ‘A blizzard’ by M. Duchamp Now, let’s add the defaults back incrementally. Figure 7.5: Layering. The plot title explains what function is being used to add each layer. This is what we mean by “layering.” As you can see, plot() not only establishes an empty canvas, but adds some default layers. And to those defaults, we can add even more! In fact, here is a list of really, really useful layering functions. Function Description abline() Adds one or more straight lines through the current plot. axis() Adds an axis to the current plot, allowing the specification of the side, position, labels, and other options. box() Draws a box around the current plot in the given color and linetype. curve() Draws a curve corresponding to a function over the interval [from, to]. grid() Adds rectangular grid to an existing plot. lines() A generic function taking coordinates given in various ways and joining the corresponding points with line segments. mtext() Writes text in one of the four margins of the current figure region or one of the outer margins of the device region. points() A generic function to draw a sequence of points at the specified coordinates. rect() Draws a rectangle (or sequence of rectangles) with the given coordinates, fill and border colors. segments() Draw line segments between pairs of points. text() Draws the strings given in the vector labels at the coordinates given by x and y. title() Add labels to a plot. Figure 7.5 shows how some of these functions work. Here is the code used to generate that plot. plot(y ~ x, type = &quot;n&quot;, xaxt = &quot;n&quot;, yaxt = &quot;n&quot;, xlab = i, ylab = &quot;&quot;, col.lab = &quot;white&quot;, frame.plot = FALSE, xlim = c(0, 1), ylim = c(0, 1)) # add box around plot region box() # add axes axis(side = 1) # x-axis to bottom axis(side = 2) # y-axis to left # add axis lables title(xlab = &quot;X&quot;, ylab = &quot;Y&quot;) # add points points(y ~ x) 7.5 Annotation Annotation refers to the addition of natural language elements (i.e., characters, words, and numerals) to a plot. These include plot titles (the main title, the subtitle, and the axis titles), as well as the legend title, axes labels (i.e., the tick labels, usually numerals), and any other text comments, either within the plot region or in the margins. Much of this may be specified within the plot() function itself. plot(y ~ x, xlab = &quot;X-axis Label&quot;, ylab = &quot;Y-axis Label&quot;, main = &quot;Main Plot Title&quot;, sub = &quot;Literally, below the plot title&quot;) Specifying these title annotations within plot() should be sufficient for simple plots, but for more fine grained control, you will want to use the title() function. plot(y ~ x, xlab = &quot;X-axis Label&quot;, ylab = &quot;Y-axis Label&quot;) title(main = &quot;Main Plot Title&quot;, col.main = &quot;red3&quot;, # color of main title line = 0.3, # inner margin line location adj = 0) # text alignment left title(sub = &quot;Literally, below the plot title&quot;, col.sub = &quot;orange3&quot;) Sometimes it is useful to label points or other geometries in the plot region. For this, R provides the text() function. As with the geometries themselves, the key here is to provide coordinates for where to locate the text. In this case, we use the point coordinates, since we are labeling them. plot(y ~ x, xlab = &quot;X&quot;, ylab = &quot;Y&quot;, xlim = c(0, 1), ylim = c(0, 1)) # create point labels having the form &quot;(x, y)&quot; point_labels &lt;- paste0(&quot;(&quot;, x, &quot;, &quot;, y, &quot;)&quot;) text(y ~ x, pos = 4, # place text on the right side of the coordinate location offset = 0.3, # add this much space between coordinate and text labels = point_labels, cex = 0.8) You can also add text to the inner or outer margins with mtext() (though, bear in mind that you will have to add outer margins before you can add text to them). Since you are plotting outside the plot region, you specify the location of text in the margin using the side, line, and adjustment (or alignment), rather than coordinates. plot(y ~ x, xlab = &quot;X&quot;, ylab = &quot;Y&quot;, xlim = c(0, 1), ylim = c(0, 1)) mtext(text = &quot;(side = 3, line = 1, adj = 1)&quot;, side = 3, line = 1, col = &quot;red3&quot;, adj = 1) mtext(text = &quot;(side = 1, line = 4, adj = 0)&quot;, side = 1, line = 4, col = &quot;darkblue&quot;, adj = 0) 7.6 Graphical Parameters Graphical parameters control aesthetic aspects of a plot, for example, color and size. R provides two ways to set these parameters. If you want to make changes to a single plot, you can supply graphical parameters to the plot() call directly. For instance, plot(y ~ x, pch = 19) supplies the plot() function with the graphical parameter pch = 19, which specifies the type of point symbol to use (in this case a filled circle). The layering functions mentioned above will also take graphical parameters in this way. You can also define graphical parameters globally, which means they will affect all plots the same way (well, more or less the same way). You do this by calling the par() function and supplying graphical parameters to it. For example, par(pch = 19) sets the point symbol to the filled circle for all plots. Sometimes you will want to set graphical parameters for several plots then revert to the original parameters for subsequent plotting. To do this, you simply assign the parameters to an object, like so: original_parameters &lt;- par() # new parameter specifications par(pch = 19) ### &lt;do some plotting here&gt; # revert to original parameters par(original_parameters) Now, let’s go over just a few of the many, many graphical parameters and how they affect your plot aesthetics. For an exhaustive list of graphical parameters and examples of their effect, see Porra (2017) “Graphical parameters of R {graphics} package” at RStudio Pubs. 7.6.1 Geometry Type R allows you to specify graphical parameters for points and lines (and by extension, polygons), for example, the type of symbol used to display the geometry. For points, this is controlled by pch. For lines, by lty. pch can take any value from 0 to 25, lty any value from 0 to 6. lty can also be specified with the words \"blank\", \"solid\", \"dashed\", \"dotted\", \"dotdash\", \"longdash\", and \"twodash\". Here is what these look like. #### Error in windowsFonts(A = windowsFont(&quot;Arial&quot;)): could not find function &quot;windowsFonts&quot; Notice that point symbols 0-14 are unfilled, 15-20 are filled and a single color, and 21-25 are filled and different colors, one for the line and one for the fill. Here is an example of changing the point symbol using our x and y vectors from above: plot(y ~ x, type = &quot;p&quot;, # &#39;p&#39; for &quot;point&quot; pch = 17, # set point type here xlab = &quot;X&quot;, ylab = &quot;Y&quot;, main = &quot;Strange Points&quot;) And here is an example of changing the line type: plot(y ~ x, type = &quot;l&quot;, # &#39;l&#39; for &quot;line&quot; lty = 4, # set line type here xlab = &quot;X&quot;, ylab = &quot;Y&quot;, main = &quot;Strange Line&quot;) 7.6.2 Text There are several ways to modify text output in a plot. Here we will focus on font type (meaning, normal, bold, or italic) and justification (or alignment, for example, centered text). These are controlled by font and adj, respectively. font can take any value from 1 to 4, adj any continuous value from 0 for left aligned to 1 for right aligned, with 0.5 being the value for centered text. 7.6.3 Color Color is an enormous topic in its own right and rightly so. For it’s one of the most important aspects of a good plot. Here, however, we can only touch on some of the issues. To begin with, R provides five graphical parameters to control the color of different plot elements. Those are the following: Parameter Description col Color of geometries in the plot region. col.axis Color of axis tick labels. col.lab Color of axis labels. col.main Color of main title. col.sub Color of subtitle. Now, we just need a way of providing the color we want to those parameters. For this, R offers a number of tools. The two most intuitive ones are perhaps the name of the color and its R number identifier. For a complete list of R color names, you can use the colors() function. all_R_colors &lt;- colors() all_R_colors[1:3] ## [1] &quot;white&quot; &quot;aliceblue&quot; &quot;antiquewhite&quot; Now we can combine these color specifications with the graphical parameters and do this: plot(y ~ x, type = &quot;n&quot;, xaxt = &quot;n&quot;, yaxt = &quot;n&quot;, xlab = &quot;&quot;, ylab = &quot;&quot;, xlim = c(0, 1), ylim = c(0, 1)) axis(side = 1, col.axis = &quot;blue4&quot;) # who comes up with these names? axis(side = 2, col.axis = &quot;blue4&quot;) points(y ~ x, pch = 19, col = &quot;darkgoldenrod&quot;) title(main = &quot;Weird Colors&quot;, line = 0.3, adj = 0, col.main = &quot;aquamarine4&quot;) title(xlab = &quot;X&quot;, ylab = &quot;Y&quot;, col.lab = &quot;darkorchid&quot;) title(sub = &quot;Can&#39;t unsee this plot.&quot;, col.sub = &quot;deeppink4&quot;) 7.6.4 Size 7.6.5 Axes 7.6.6 Margins 7.6.7 Miscellaneous 7.7 Multi-plot Layouts References "],["vector-types.html", "Chapter 8 Vector Types 8.1 Overview 8.2 Data types 8.3 Vector types 8.4 Coercion 8.5 Environments", " Chapter 8 Vector Types Figure 8.1: The R Menagerie 8.1 Overview Goal To familiarize students with the ontology of the R Programming Environment. tl;dr The beings of R are objects. Outcomes Here, you will learn about R objects, specifically vectors, how to create them, what kinds there are, and how to index them. Datasets NONE Requirements NONE Further Reading An Introduction to R (R Core Team 2020a)Advanced R (Wickham 2015) R contains a variety of objects, the most notable being functions and vectors. These live in the R environment (environments, actually). While there is a lot to say about functions and environments, those are mostly super-class ‘A’ R programming topics, verboten for an introductory text. The bulk of this chapter will, thus, be devoted to vectors. Vectors can take a number of different forms, for example, scalars and lists (see Fig. 8.2). In a sense (a slightly misleading sense), these objects are vessels that hold different data types, the four primary ones being integer, double (i.e., fractions), logical, and character. Putting effort into understanding these vector forms and data types might at first blush feel like a foolhardy pursuit of the inconsequential and esoteric, a task best relegated to crusty old philosophers. It is, however, of the utmost importance, for the different statistical questions you might want to ask will require data in one or the other form and type to answer. If, for example, you want to get the mean of some distribution, say the average height of actors who auditioned for the part of Aragorn in the timeless cinematic classic Lord of the Rings, you will only need a simple vector of double values. If, however, you want to know whether height varies as a function of diet, you will want a more complex object, specifically a data.frame. And, if you prefer order to chaos, you will surely enjoy lists. Figure 8.2: One possible phylogeny of R objects. Fig. 8.2 might seem a little overwhelming at first, but don’t let it intimidate you. Its meaning will become clear as we proceed. 8.2 Data types There are four primary data types in R: integer, double, logical, and character. The first two are probably more important for statistics, the latter two for data processing (or ‘wrangling’, as it is often called). We will not discuss any of these in great detail here, pausing only to mention very briefly what each is, how to make them, how to catch one in the wild, and what they are for. As an honorable mention, we will also discuss factors here. These are not strictly their own data type,9 but they are ubiquitous and utilized quite often in statistical analyses. So, we’ll treat them as an honorary data type in their own right, on a level with the others (even if they aren’t, technically). 8.2.1 Integer What is it? A whole number or a number without a fractional component (like 1 as opposed to 1.3). What is it for? Counting things! For example, how many students are in this class? One would hope the answer to that is an integer. How do you make one? By appending an L to a number. my_integer &lt;- 3L How to catch one in the wild? By asking “Is this an integer?” is.integer(4.2) ## [1] FALSE is.integer(my_integer) ## [1] TRUE 8.2.2 Double What is it? A number with a fractional component (like 1.3 as opposed to 1). What is it for? Measuring things! For example, how much coffee did I have this morning? Or, how much did it rain last year in Pasquotank County, North Carolina? How do you make one? By typing a number (with or without a fraction, but no L). my_double &lt;- 3.2 How to catch one in the wild? By asking “Is this a double?” is.double(3L) ## [1] FALSE is.double(my_double) ## [1] TRUE 8.2.3 Character What is it? A string of symbols used to construct words in a natural language (by default, English letters). What is it for? Saying things! For example, how many students are in this class? One would hope the answer to that is an integer. How do you make one? By quoting it, i.e., surrounding a string with double \" or single ' apostrophes. my_character &lt;- &#39;quotidian&#39; A quick warning: if you do not surround the character with apostrophes, R will think you are trying to call an object with that name. If that object does not exist, R will protest. quotidian #### Error in eval(expr, envir, enclos): object &#39;quotidian&#39; not found Similarly, if you use quote marks around a named object, R treats it as a character string, rather than a call to the object. &quot;my_integer&quot; ## [1] &quot;my_integer&quot; my_integer ## [1] 3 How to catch one in the wild? By asking “Is this a character?” is.character(4.2) ## [1] FALSE is.character(my_character) ## [1] TRUE 8.2.4 Logical What is it? A truth condition, i.e., TRUE or FALSE. Also known as a boolean. What is it for? Implying things! Specifically, making conditional or hypothetical claims. For example, if it rains today, I will take my umbrella. Or, closer to home, “Hi R, if this is an integer, please add one to it.” How do you make one? By typing TRUE, FALSE, T, or F. my_logical &lt;- TRUE You can also create logicals in R using statements that R can evaluate for their truth or falsity. For example, # is 2 greater than 5? 2 &gt; 5 ## [1] FALSE # is 7 greater than or equal to itself? 7 &gt;= 7 ## [1] TRUE # is &#39;cat&#39; the same string as &#39;hat&#39; &#39;cat&#39; == &#39;hat&#39; ## [1] FALSE And the truth conditions of these statements can, of course, be assigned to names. jim_bob &lt;- &#39;cat&#39; == &#39;hat&#39; How to catch one in the wild? By asking “Is this a logical?” is.logical(my_double) ## [1] FALSE is.logical(my_logical) ## [1] TRUE Did you notice that our is.* functions all return a logical? 8.2.5 Factors What is it? Categories, typically represented in R as character strings with “levels.” What is it for? Categorizing things! For example, “Tom is a feline” or “Jerry is a mouse.” How do you make one? With the function factor(). my_factor &lt;- factor(&quot;Australian&quot;) my_factor ## [1] Australian ## Levels: Australian Notice that unlike a simple character, a factor has “levels.” These levels are the categories of the factor variable. A good example is nationality. Nationality is a factor, with the specific levels or categories of that factor including, for instance, American, Australian, Chinese, and French. How to catch one in the wild? By asking “Is this a factor?” is.factor(&quot;quotidian&quot;) ## [1] FALSE is.factor(my_factor) ## [1] TRUE 8.3 Vector types Vectors come in two general flavors: atomic and complex. These differ in one crucial respect. While atomic vectors are limited to one data type, complex vectors can contain many data types. As shown in Fig. 8.2, atomic vectors include scalars, vectors, and matrices. Complex vectors include lists and data.frames. 8.3.1 Scalar A scalar-vector is an atomic vector that contains only one element. Hence, by definition, it can include only one data type. Here, we represent this with a square, which includes a value and is color-coded by its data type. Note that all the examples we have used so far have been scalar vectors. You can check this using the length() function. length(my_integer) ## [1] 1 8.3.2 Vector A vector-vector is an atomic vector that contains multiple elements. These multi-scalar atomic vectors do not really have a name like “list” or “scalar,” but in common R parlance the word ‘vector’ is often used as a synonym, which is a tad confusing, like “Are you going to New York (the state) or New York (the city)?” In what follows, we’ll just cross our fingers and hope the context is sufficient to tell the difference. The standard way to create one of these is to use the concatenate function on scalars c(). my_vector &lt;- c(1, 2, 3, 4, 5) length(my_vector) ## [1] 5 Of course, you can have a vector of any data type, it just cannot be the case that any vector contains multiple data types. integer_vector &lt;- c(1L, 2L, 3L, 4L, 5L) double_vector &lt;- c(1.1, 0.2, 3.1, 4, 5.2) character_vector &lt;- c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;) logical_vector &lt;- c(TRUE, TRUE, FALSE, FALSE, TRUE) What happens if you try to create a vector with different data types? c(1, &#39;a&#39;, TRUE) ## [1] &quot;1&quot; &quot;a&quot; &quot;TRUE&quot; It converted them all to character strings! This is known as implicit coercion. It is a way of ensuring that all vector-vectors are atomic. 8.3.3 Matrix A matrix-vector is an atomic vector with dimensions, meaning the vector is “folded,” so to speak, into rows and columns. As you can see, a matrix has the shape of a data table, like what you would find in an Excel spreadsheet. To create a matrix, you use the matrix() function by providing it with a vector and then specifying the number of rows and columns it should have. my_matrix &lt;- matrix(my_vector, nrow = 2, # number of rows ncol = 3) # number of columns my_matrix ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 1 The odd, bracketed numbers printed above and to the left of the matrix are known as subscripts. They are like numeric names for columns and rows that can be used to reference specific locations in the matrix. For example, row one is [1,], and column two is [,2]. So, if I want to refer to the cell containing the value 3, I use [1,2]. If you want to know how many rows and columns a matrix has, you can use nrow and ncol. ncol(my_matrix) ## [1] 3 8.3.4 List A list-vector is a complex vector that may include other vectors of any data type and length. The gray box around each vector in the figure below is meant to suggest that the list is a single complex vector made up of other vectors, and the space between each vector is meant to show that they are still separate components of the list, unconstrained by the other components. So, yeah, a list… To create a list, use the list() function and supply it with vectors. Be sure to assign list-names using the name = vector syntax. my_list &lt;- list(&#39;c1&#39; = c(1L, 2L, 3L, 4L), &#39;c2&#39; = double_vector, &#39;c3&#39; = c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), &#39;c4&#39; = c(TRUE, TRUE)) my_list ## $c1 ## [1] 1 2 3 4 ## ## $c2 ## [1] 1.1 0.2 3.1 4.0 5.2 ## ## $c3 ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## $c4 ## [1] TRUE TRUE Each vector in the list is called a component. You can find out what list-names these components have using the names() function, which returns a character vector. names(my_list) ## [1] &quot;c1&quot; &quot;c2&quot; &quot;c3&quot; &quot;c4&quot; You can also assign new names to a list with names() and the assignment arrow &lt;-. names(my_list) &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;) names(my_list) ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; Now, we said above that lists can contain any vector type, and this is true. Lists can even contain other lists! my_super_list &lt;- list(&#39;e&#39; = my_list, &#39;f&#39; = my_logical) In this sense, you will sometimes hear people refer to lists as recursive vectors (R Core Team 2020a). 8.3.5 Data.frame A data.frame-vector is a special sort of list with a super-restriction on it: all the vectors it includes must be of the same length. It is also not recursive. To create a data.frame, use the data.frame() function, supplying it with name = vector arguments as you would with list(). my_dataframe &lt;- data.frame(&#39;c1&#39; = integer_vector, &#39;c2&#39; = double_vector, &#39;c3&#39; = character_vector, &#39;c4&#39; = logical_vector) my_dataframe ## c1 c2 c3 c4 ## 1 1 1.1 a TRUE ## 2 2 0.2 b TRUE ## 3 3 3.1 c FALSE ## 4 4 4.0 d FALSE ## 5 5 5.2 e TRUE Notice that when you create the data.frame, the vectors become named columns. To extract those names, we can again use the names() function. names(my_dataframe) ## [1] &quot;c1&quot; &quot;c2&quot; &quot;c3&quot; &quot;c4&quot; As with a matrix, you can also get the number of columns and rows with nrow and ncol. nrow(my_dataframe) ## [1] 5 8.4 Coercion R provides tools for transforming objects of one data or vector type to other data and vector types. This is known as coercion, which you were introduced to above in the form of implicit coercion. But, what about explicit coercion, meaning coercion you declare explicitly with R code? Well, R provides several functions for this, all having the form as.*() where the * is replaced with the name of the type that you wish to coerce your object to. Why care about coercion? Well, when it comes to coercion of data type, perhaps the most important reason is that you do not want to mistakenly compare apples and oranges. R’s implicit coercion rules. Data Type Coercion Here is an example of data type coercion from integer to character. a_new_character &lt;- as.character(integer_vector) a_new_character ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; is.integer(a_new_character) ## [1] FALSE As you see, it surrounds the numerals with quotation marks, indicating these are now character strings. Other data type coercion functions include as.integer(), as.numeric(), as.logical(), and as.factor(). But, notice that R can be somewhat finicky about this. I mean, converting from logical, numeric, or integer to character is obvious. Just wrap the elements in quotes. But, what should R do when you ask it to convert integers to logicals or doubles to integer? double_vector ## [1] 1.1 0.2 3.1 4.0 5.2 as.integer(double_vector) ## [1] 1 0 3 4 5 In this case, it rounds the decimals to whole numbers. Vector Type Coercion a_new_list &lt;- as.list(my_dataframe) a_new_list ## $c1 ## [1] 1 2 3 4 5 ## ## $c2 ## [1] 1.1 0.2 3.1 4.0 5.2 ## ## $c3 ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; ## ## $c4 ## [1] TRUE TRUE FALSE FALSE TRUE is.data.frame(a_new_list) ## [1] FALSE 8.5 Environments So, we now know how to create an object in R, but when we do, where does it go?!!! This is a question that a lot of smart people find themselves asking when first learning about R. While the answer is a tad on the esoteric side, it is perhaps useful to peel back the curtain ever so slightly, so you can see what is happening when you create an object in R. To do that, we need to talk about environments, in particular, the “global” environment or “workspace.” You can think of an environment like the workspace as a special sort of named list. bob &lt;- list(a = 1:5, b = LETTERS[1:10], c = &quot;quotidian&quot;, d = TRUE) # coerce list to environment object digital_zoo &lt;- as.environment(bob) When you create an object, you do not have to go through these steps explicitly for R adds objects assigned to names to your global environment by default. The key here is just to recognize that when you use &lt;-, you are in effect adding an element to a list, the environment list. If you want to know what all lives in your R environment, you can try ls(), which works like names() does for lists, printing the names of its denizens. ls(digital_zoo) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; As a general rule, you should keep your environments clean and orderly. This will help prevent you from making careless mistakes (like running operations on the wrong objects) and also make it easier to manage your workflow. One way to do this is to let go of objects that you will not re-use - meaning, you should banish them from your environment. This is achieved with the rm() function. rm(a, envir = digital_zoo) # read this as: remove object a from the digital zoo environment When you’re removing objects from your global environment or workspace (and not the toy environment that I just created as an example), it is sufficient simply to type rm(&lt;object&gt;) without specifying the environment, since it defaults to the global environment anyway. References "],["workspace-management.html", "Chapter 9 Workspace Management 9.1 The Working Directory", " Chapter 9 Workspace Management 9.1 The Working Directory "],["vector-indexing.html", "Chapter 10 Vector Indexing 10.1 Exploring your data 10.2 Indexing your data", " Chapter 10 Vector Indexing 10.1 Exploring your data 10.2 Indexing your data You will often need to access specific elements of a vector you have created, rather than use the whole vector itself. To do access those elements, however, we need some way of referring to or indexing them. That’s where indexing vectors come in, which we supply to the object we want to index using the single brackets operator [. Strictly speaking you can use any data type to define an indexing vector, but the three that are most useful (and really the only three you should ever use) are: Integer. This indexes by position. Logical. This indexes by condition. Character. This indexes by name. 10.2.1 Integer Indexing With integer indexing, you select elements by their literal position in a vector (see @ref(fig:r-objects_vector_position)). As you see, this contains five scalars (the letters ‘a’ through ‘b’), with the position of each just being a numbered location, starting with one for the first scalar and increasing by one for each additional scalar. We can create this vector in the usual way. a_vector &lt;- c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;) Now, we can create an integer index, i, and apply it to our vector like so. i &lt;- 3 a_vector[i] ## [1] &quot;c&quot; We can also provide multiple integers as an index. i &lt;- c(1, 3, 5) a_vector[i] ## [1] &quot;a&quot; &quot;c&quot; &quot;e&quot; For brevity, we can also supply the vector directly. a_vector[3] a_vector[c(1, 3, 5)] Finally, we can also supply negative integers to identify positions we do not want to return. a_vector[-i] ## [1] &quot;b&quot; &quot;d&quot; 10.2.2 Logical Indexing With logical indexing, you are indexing a vector according to a condition, such that each element in the vector that satisfies that condition is returned and each element that fails is discarded. How do we evaluate elements in a vector according to a condition? By including the vector in a statement that R can evaluate for its truth or falsity. The result is a logical vector, which can be used as our logical index. Consider this numeric vector: a_vector &lt;- c(1.1, 0.2, 3.1, 4, 5.2) Now, perhaps, we want to return only those elements that are, say, greater than 3. i &lt;- a_vector &gt; 3 i ## [1] FALSE FALSE TRUE TRUE TRUE a_vector[i] ## [1] 3.1 4.0 5.2 As before, we can supply the logical condition directly with a_vector[a_vector &gt; 3]. And we can invert our logical condition using the negation operator, ! (sometimes pronounced “bang”). !i ## [1] TRUE TRUE FALSE FALSE FALSE a_vector[!i] ## [1] 1.1 0.2 Logical indexing offers an important advantage over integer indexing, namely, that you do not have to know the exact position of elements beforehand. This is especially true when your vectors are quite large. I mean, just try and appreciate the difficulty that would surely accompany specifying the position of more than ten elements, more than one hundred elements, or even a thousand! No thanks. 10.2.3 Character Indexing With character indexing, you reference objects in a vector by their given name. Suppose, for example, that our toy vector came with these names: avengers &lt;- c(&quot;spiderman&quot;, &quot;blackwidow&quot;, &quot;hulk&quot;, &quot;ironman&quot;, &quot;scarlet_witch&quot;) names(a_vector) &lt;- avengers We could then assemble a subset of our vector by defining a character index. i &lt;- c(&quot;spiderman&quot;, &quot;blackwidow&quot;, &quot;ironman&quot;) a_vector[i] # Natasha Lives ## spiderman blackwidow ironman ## 1.1 0.2 4.0 For completeness, it is perhaps worth noting that indexing with a blank space \" \", as in a_vector[ ], indexes every element in the vector. 10.2.4 Assignment and Replacement Now that we know how to index into a vector, it’s worth pausing briefly to think about what we can do with our index. For one, we can use them to assign the indexed elements to a new object. new_object &lt;- a_vector[i] But, less obviously, we can replace the indexed elements with new ones. a_vector[i] &lt;- c(2.3, 4.1, 3.8) 10.2.5 Complex Indexing What about complex vectors, like matrices, lists, and data.frames? integer_vector &lt;- c(1L, 2L, 3L, 4L, 5L) double_vector &lt;- c(1.1, 0.2, 3.1, 4, 5.2) character_vector &lt;- c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;) logical_vector &lt;- c(TRUE, TRUE, FALSE, FALSE, TRUE) my_vector &lt;- c(1, 2, 3, 4, 5) my_matrix &lt;- matrix(my_vector, nrow = 2, ncol = 3) my_list &lt;- list(&#39;c1&#39; = c(1L, 2L, 3L, 4L), &#39;c2&#39; = double_vector, &#39;c3&#39; = c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), &#39;c4&#39; = c(TRUE, TRUE)) my_dataframe &lt;- data.frame(&#39;c1&#39; = integer_vector, &#39;c2&#39; = double_vector, &#39;c3&#39; = character_vector, &#39;c4&#39; = logical_vector) 10.2.6 Matrix Because a matrix has “dimensions,” a unique index requires a little more work. As noted above, we need to specify both the row and column subscripts. Well, actually, if you specify no row, but just a column, R will return all rows. Similarly, if you specify one row, but no columns, R will return all columns. Some examples, # just a reminder my_matrix ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 1 my_matrix[1, 2] ## [1] 3 my_matrix[1, ] ## [1] 1 3 5 my_matrix[, 3] ## [1] 5 1 Note that indexing a matrix in this way returns a vector. In fact, when you index a matrix, you are, in effect, unfolding its vector. 10.2.7 List List components have positions like scalars in a vector, so you can access them with [ in the same way. my_list[c(1, 2, 3)] ## $c1 ## [1] 1 2 3 4 ## ## $c2 ## [1] 1.1 0.2 3.1 4.0 5.2 ## ## $c3 ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; Note that this simply returns a smaller list. What if we wanted just a vector back? This is the purpose of the double-brackets [[. my_list[[2]] ## [1] 1.1 0.2 3.1 4.0 5.2 The dollar $ does the same thing. Returning one of the vectors initially used to create the list. Here, however, instead of providing the numeric position of the component, you supply the name of the desired component in the list. my_list$c2 ## [1] 1.1 0.2 3.1 4.0 5.2 Now, because these return a vector, we can also subset that with [! my_list[[2]][3] ## [1] 3.1 This is R reminding you that a list has “depth,” that it is a vector of vectors (of vectors of vectors…). 10.2.8 Data.frame A data.frame is indexed like a matrix, with subscripts for rows and columns. my_dataframe[2, 4] ## [1] TRUE my_dataframe[1, ] ## c1 c2 c3 c4 ## 1 1 1.1 a TRUE my_dataframe[, 3] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; Notice that when you index a row, it returns a data.frame with just that row, but when you index a column, it returns the vector that column contains. # my_dataframe[, 3] is equivalent to my_dataframe$c3 ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; "],["data-wrangling.html", "Chapter 11 Data Wrangling 11.1 Overview 11.2 Handling Missing Data", " Chapter 11 Data Wrangling Figure 4.1: Artwork by Allison Horst 11.1 Overview Goal To teach students how to manipulate and massage raw data into a format suitable for statistical analysis. tl;dr Managing data is challenging in any context, but at least it’s reproducible in R. Outcomes Here, you will learn about importing and exporting data indexing R objects, data wrangling, conditionals, and handling missing values. Datasets Palmer Penguins (Horst, Hill, and Gorman 2020) Requirements NONE Further Reading An Introduction to R (R Core Team 2020a) 11.1.1 Arrange [sort(), order()] 11.1.2 Combine [c(), rbind(), cbind(), merge()] 11.1.3 Change [transform()] 11.1.4 Filter [subset()] 11.1.5 Select [subset()] 11.1.6 Reshape [reshape()] 11.2 Handling Missing Data References "],["whatisstats.html", "Chapter 12 What is Statistics?", " Chapter 12 What is Statistics? \\[ \\begin{aligned} y &amp;= E(y) + \\epsilon \\\\ E(y) &amp;= mu \\\\ \\epsilon &amp;\\sim N(0, sigma) \\\\ \\end{aligned} \\] I like this because it is modular. You can use this to explain: - what does E(y) mean? It’s the expected value or what you would guess as the value for any new observation of y. Why is it constant? Well, we don’t have any other information to control how it varies. o Now it’s a short step to add in X. And the nice thing is that you only now have to change the E(y) definition to E(y) = beta X. - What does sigma mean? It’s a measure of how much observed y varies around mu. We don’t know exactly what this variation might be, but we can try to quantify the range of errors. o Better yet, we don’t just say that the variation is between +/- sigma, but that there is probability of errors, which is higher closer to mu, and then drops off away from it. o It’s easy then to change the description of the errors. We’ve used a normal distribution, but if your data don’t match this, you can change N(0, sigma) to Pois(lambda), or Binom(pi) giving you a GLM. (You need a link function as well, but that’s pretty straightforward) o You can use this to explain iid – why is the 0 important in the errors? It’s so that the errors are unbiased (which they should be), and that these are symmetric with a normal distribution - Other things: o You can explain heteroscedascity by changing sigma to sigma_i o Mixed models change sigma to sigma_j (where j is the group membership) o Temporal or spatial models just alter sigma to two components, u and v, and then you can start to explain how you model u (the spatial error). "],["univariate-description.html", "Chapter 13 Univariate Description", " Chapter 13 Univariate Description "],["probability-distributions.html", "Chapter 14 Probability Distributions", " Chapter 14 Probability Distributions "],["inference-tests.html", "Chapter 15 Inference Tests", " Chapter 15 Inference Tests "],["multivariate-description.html", "Chapter 16 Multivariate Description", " Chapter 16 Multivariate Description "],["ols.html", "Chapter 17 Linear Models", " Chapter 17 Linear Models "],["model-diagnostics.html", "Chapter 18 Model Diagnostics", " Chapter 18 Model Diagnostics "],["glm.html", "Chapter 19 Generalized Linear Models", " Chapter 19 Generalized Linear Models "],["references.html", "References", " References "]]
